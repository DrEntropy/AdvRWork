# Chapter 8 Notes and Exercises

```{r}
library(rlang)
```
## Notes


## Exercises

### 8.2.4

1)

```{r}

file.remove.safe <- function(filename){
  if(!file.exists(filename))
    stop(paste0("<",filename,"> doesn't exist"), call. = FALSE)
  file.remove(filename)
}
```

2) appendLF (which defaults to TRUE) indicates that a character string message should have a linefeed appended.

### 8.4.5

1)
```{r}
cnd_stop <- catch_cnd(stop("An error"))
cnd_abort <- catch_cnd(abort("An error"))
```

Inspecting these objects and examining the help reveals that the abort has some extra information, a "trace" which gives an rlang "trace" object (containing a full backtrace), as well as a "parent" (whatever that is).  

2)  

```{r}
show_condition <- function(code) {
  tryCatch(
    error = function(cnd) "error",
    warning = function(cnd) "warning",
    message = function(cnd) "message",
    {
      code
      NULL
    }
  )
}

```


Prediction -> An error with message "error"
```{r}
show_condition(stop("!"))
```
Prediction -> Null, since the return value from `code` is unused.

```{r}
show_condition(10)
```
Prediction ->   "warning" only because tryCatch exists after catch

```{r}
show_condition(warning("?!"))
```

 Prediction > "message" only because tryCatch exists after catch
 
```{r} 
show_condition({
  10
  message("?")
  warning("?!")
})
```

3)

```{r}
withCallingHandlers(
  message = function(cnd) message("b"),
  withCallingHandlers(
    message = function(cnd) message("a"),
    message("c")
  )
)
```

When the inner `message("c")` is called, it bubbles up first to the inner handler, which call's  `message("a")`, which is caught by the outer handler that calls message("b") which just prints "b" since this is handled by the global handler. It then hands `message("a")` off to the 'global' handler that prints "a".  Then the outher handler get's its turn at handling the inner `message("c")`, which causes "b" to be printed one more time, and then finally the inner `message("c)` gets handed to global handler the final 'c' is printed.


4)
catch_cnd source code looks lke this:

```
function (expr, classes = "condition") 
{
    stopifnot(is_character(classes))
    handlers <- rep_named(classes, list(identity))
    eval_bare(rlang::expr(tryCatch(!!!handlers, {
        force(expr)
        return(NULL)
    })))
}
```
This requires understanding some things that are introduced later (like '!!!' , eval_bare, etc). But I think what it does is uses a tryCatch to evaluate the expression and then capture the condition using an identity function handler.  According to the solution manual the original version of `catch_cmd` was simpler.

5)

The documentation of tryCatch is a bit ... opaque. After reading through I realized that arguments that match a condition class will be called when the condition matches that condition class. And further the root class for conditions is 'condition'. BTW have we covered S3 classes yet? No? No we have not.

```{r}
show_condition <- function(code) {
  tryCatch(
condition = function(cnd) {
  switch(class(cnd)[1],
      simpleWarning="warning",
      simpleError = "error",
      simpleMessage= "message")
},
    {
      code
      NULL
    }
  )
}

show_condition(warning("?!"))
show_condition(error("f"))
```

